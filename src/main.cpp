/*
 * main.cpp
 *
 *  Created on: Aug 1, 2016
 *      Author: root
 */

#include <iostream>
#include <unistd.h>
#include <thread>
#include <string>
#include <pcap.h>
#include <list>
#include <unordered_map>
#include <libndpi-1.8.0/libndpi/ndpi_main.h>

#include "Mutex_list.h"
#include "Exception.h"
#include "pcap_process.h"
#include "detection.h"
#include "Device.h"
#include "json/json.h"
#include "ndpi_util.h"

#include "Vulnerability.h"

bool WriteToFile(const char* filename, const char* buffer, int len);
bool ReadFromFile(const char* filename, char* buffer, int len);
bool WriteJson();
bool ModifyJson();
void json_thread_func();

static bool operator < (const ndpi_protocol &_lhs, const ndpi_protocol &_rhs) {
    return _lhs.master_protocol < _rhs.master_protocol;
}

Mutex_List<std::pair<pcap_pkthdr *, u_char *>> packet_queue;
Mutex_List<sub_container> sub_queue;
std::unordered_map<unsigned long, Device *> dev_table;

bool addr_option = false;
bool mask_option = false;

in_addr net_addr;
in_addr net_mask;

extern ndpi_workflow * workflow;
extern pcap_t * pcd;
bool stop_soon = false;


int main(int argc, char *argv[]) {
	std::thread *pcap_thread;
	std::thread *protocol_detection_thread;
    std::thread *os_detection_thread;
    std::thread *json_thread;

	std::string str;
    
    std::unordered_map<unsigned long, Device *>::iterator iter;

    int arg_cnt = 1;

    while (arg_cnt < argc) {
    	std::string option(argv[arg_cnt++]);

    	if (option == "-a" || option == "--addr") {
    		std::string addr(argv[arg_cnt]);

    		inet_aton(addr.c_str(), &net_addr);
    		addr_option = true;
    	}
    	else if (option == "-m" || option == "--mask") {
    		std::string mask(argv[arg_cnt]);

    		inet_aton(mask.c_str(), &net_mask);
    		mask_option = true;
    	}
    }

	pcap_init();
	protocol_detection_init(pcd);
    init_os_detection();
    read_vulnerability();
    
	pcap_thread = new std::thread(run_pcap_process);
	protocol_detection_thread = new std::thread(run_protocol_detection);
    os_detection_thread = new std::thread(run_os_detection);
    json_thread = new std::thread(json_thread_func);

	std::cin >> str;

	stop_pcap_process();
	stop_protocol_detection();

	pcap_thread->join();
	protocol_detection_thread->join();
    os_detection_thread->join();
    json_thread->join();
    
    
    
	delete pcap_thread;
	delete protocol_detection_thread;
    delete os_detection_thread;
    delete json_thread;
    
    for (iter = dev_table.begin(); iter != dev_table.end(); iter++) {
        std::cout << "IP : " << inet_ntoa(*(in_addr *) &iter->first) << std::endl;
        std::cout << "OS : " << iter->second->get_os() << std::endl;
        std::cout << "Protocols" << std::endl;
        
        iter->second->print_proto();
    }

	return 0;
}

bool WriteToFile(const char* filename, const char* buffer, int len) {
    FILE* r = fopen(filename, "wb");
    
    if (NULL == r)
        return false;
    
    size_t fileSize = fwrite(buffer, 1, len, r);
    fclose(r);
    
    return true;
}

bool ReadFromFile(const char* filename, char* buffer, int len) {
    FILE* r = fopen(filename, "rb");
    if (NULL == r)
        return false;
    size_t fileSize = fread(buffer, 1, len, r);
    fclose(r);
    return true;
}

bool WriteJson() {
    std::unordered_map<unsigned long, Device *>::iterator dev_iter;
    
    Json::Value tmp_vul;
    Json::Value tmp_score;

    // Declare
    Json::Value root;
    Json::Value nodes;
    Json::Value links;
    
    int id = 0;
    
    tmp_vul.append("none");
   // tmp_vul.append("none");
    tmp_score.append(0.0);
    //tmp_score.append(0.0);


    Json::Value root_node;
    
    root_node["id"] = id++;
    root_node["layer"] = 1;
    root_node["name"] = "server";
    root_node["vulner"] = tmp_vul;
    root_node["score"] = tmp_score;

    nodes.append(root_node);
    
    for (dev_iter = dev_table.begin(); dev_iter != dev_table.end(); dev_iter++) {
        int dev_id = id++;
        int os_id;
        
        std::string os;
        
        Json::Value dev_node;
        Json::Value dev_link;
        Json::Value os_node;
        Json::Value os_link;
        Json::Value os_vuls;
        Json::Value os_vul_scores;
        Json::Value os_vul;
        Json::Value os_vul_score;
        
        dev_node["id"] = dev_id;
        dev_node["layer"] = 2;
        dev_node["name"] = inet_ntoa(*(in_addr *) &dev_iter->first);
        dev_node["vulner"] = tmp_vul;
        dev_node["score"] = tmp_score;
        
        dev_link["source"] = 0;
        dev_link["target"] = dev_id;
        
        
        nodes.append(dev_node);
        links.append(dev_link);
        
        os_id = id++;
        
        //std::string os_vuls = "";
        std::list<Vulnerability> tmp = dev_iter->second->get_vul_list();
        std::list<Vulnerability>::iterator vul_iter;

        for (vul_iter = tmp.begin(); vul_iter != tmp.end(); vul_iter++) {
        	os_vul = vul_iter->get_id();
        	os_vul_score = vul_iter->get_score();
        	os_vuls.append(os_vul);
        	os_vul_scores.append(os_vul_score);
        }

        if (os_vuls.empty()) {
        	os_vuls.append("Unknown");
        	os_vul_scores.append(0.0);
        }

        os_node["id"] = os_id;
        os_node["layer"] = 3;
        os_node["name"] = dev_iter->second->get_os();
        os_node["vulner"] = os_vuls;
        os_node["score"] = os_vul_scores;
        
        os_link["source"] = dev_id;
        os_link["target"] = os_id;
        
        nodes.append(os_node);
        links.append(os_link);
        
        std::map<const ndpi_protocol, size_t> proto_table = dev_iter->second->get_proto_table();
        std::map<const ndpi_protocol, size_t>::iterator proto_iter;
        
        for (proto_iter = proto_table.begin(); proto_iter != proto_table.end(); proto_iter++) {
            int proto_id = id++;
            char buf[256];
            Json::Value proto_node;
            Json::Value proto_link;
            
            proto_node["id"] = proto_id;
            proto_node["layer"] = 4;
            proto_node["name"] = ndpi_get_proto_name(workflow->ndpi_struct, proto_iter->first.master_protocol);
            proto_node["vulner"] = tmp_vul;
            proto_node["score"] = tmp_score;
            
            proto_link["source"] = os_id;
            proto_link["target"] = proto_id;
            
            nodes.append(proto_node);
            links.append(proto_link);
        }
    }
    
    root["nodes"] = nodes;
    root["links"] = links;
    
    Json::StyledWriter writer;
    std::string outputConfig = writer.write(root);
    
    bool result = WriteToFile("data.json", outputConfig.c_str(), outputConfig.length());
    return result;
}

bool ModifyJson() {
    const int BufferLength = 1024;
    char readBuffer[BufferLength] = { 0, };
    
    if (false == ReadFromFile("myflag.json", readBuffer, BufferLength))
        return false;
    
    std::string config_doc = readBuffer;
    Json::Value root;
    Json::Reader reader;
    
    bool parsingSuccessful = reader.parse(config_doc, root);
    
    if (!parsingSuccessful) {
        std::cout << "Failed to parse configuration\n" << reader.getFormatedErrorMessages();
        return false;
    }
    
    int flag = root.get("flag", "").asInt();
    root["flag"] = ++flag;
    
    Json::StyledWriter writer;
    std::string outputConfig = writer.write(root);
    
    bool result = WriteToFile("myflag.json", outputConfig.c_str(), outputConfig.length());
    return result;
}

void json_thread_func() {
	while (!stop_soon) {
		sleep(5);
		ModifyJson();
		WriteJson();
	}
}
