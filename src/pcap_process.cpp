/*
 * pcap_process.cpp
 *
 *  Created on: Aug 3, 2016
 *      Author: root
 */

#include "pcap_process.h"

#include <iostream>
#include <cstdlib>
#include <cstring>
#include <arpa/inet.h>
#include <pcap.h>

#include "Mutex_list.h"
#include "Exception.h"

extern Mutex_List<std::pair<pcap_pkthdr *, u_char *>> packet_queue;

char *dev;
pcap_t *pcd;

void pcap_init() {
	char err_msg[ERR_MSG_SIZE];
	char errbuf[PCAP_ERRBUF_SIZE];

	bpf_u_int32 net;
	bpf_u_int32 mask;

	in_addr net_addr;
	in_addr msk_addr;

	bpf_program fp;

	memset(err_msg, 0, ERR_MSG_SIZE);

	std::cout << "*** pcap initializing start ***" << std::endl;

	dev = pcap_lookupdev(errbuf);
	if (dev == NULL) {
		strncpy(err_msg, "0x00000001 ", 12);
		throw Exception(strcat(err_msg, errbuf));
	}

	std::cout << "DEV : " << dev << std::endl;

	if (pcap_lookupnet(dev, &net, &mask, errbuf) == PCAP_FUNC_ERR) {
		strncpy(err_msg, "0x00000002 ", 12);
		throw Exception(strcat(err_msg, errbuf));
	}

	net_addr.s_addr = net;
	msk_addr.s_addr = mask;

	std::cout << "NET : " << inet_ntoa(net_addr) << std::endl;
	std::cout << "NSK : " << inet_ntoa(msk_addr) << std::endl;

	pcd = pcap_open_live(dev, BUFSIZ, PROMISCUOUS, 0, errbuf);
	if (pcd == NULL) {
		strncpy(err_msg, "0x00000003 ", 12);
		throw Exception(strcat(err_msg, errbuf));
	}

	std::cout << "live pcap opening success." << std::endl;
	/*
	 if (pcap_setnonblock(pcd, 1, errbuf) == PCAP_FUNC_ERR) {
	 strncpy(err_msg, "0x00000004 ", 12);
	 throw Exception(strcat(err_msg, errbuf));
	 }
	 */
	std::cout << "setting non-block option success." << std::endl;

	if (pcap_compile(pcd, &fp, NULL, 0, net) == PCAP_FUNC_ERR) {
		strncpy(err_msg, "0x00000005 ", 12);
		throw Exception(strcat(err_msg, errbuf));
	}

	std::cout << "pcap_compile success." << std::endl;

	if (pcap_setfilter(pcd, &fp) == PCAP_FUNC_ERR) {
		strncpy(err_msg, "0x00000006 ", 12);
		throw Exception(strcat(err_msg, errbuf));
	}

	std::cout << "pcap_setfilter success." << std::endl;

	std::cout << "*** pcap initializing success ***" << std::endl;

}

static void pcap_callback(u_char *_args, const pcap_pkthdr *_pkthdr, const u_char *_packet) {
	pcap_pkthdr *pkthdr = (pcap_pkthdr *) malloc(sizeof(pcap_pkthdr));
	u_char *checked_packet = (u_char *) malloc(_pkthdr->caplen);

	memcpy(pkthdr, _pkthdr, sizeof(pcap_pkthdr));
	memcpy(checked_packet, _packet, _pkthdr->caplen);

	packet_queue.lock();
	packet_queue.push_back(std::pair<pcap_pkthdr *, u_char *>(pkthdr, checked_packet));
	packet_queue.unlock();
}

void run_pcap_process() {
	pcap_loop(pcd, 0, pcap_callback, NULL);
}

void stop_pcap_process() {
	pcap_breakloop(pcd);
}
