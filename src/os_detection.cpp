/*
 * os_detection.cpp
 *
 *  Created on: Aug 10, 2016
 *      Author: root
 */
#include <string>
#include <cstdlib>
#include <pcap.h>
#include <unordered_map>
#include <vector>
#include <fstream>

#include <iostream>

#include "Mutex_list.h"
#include "detection.h"
#include "Device.h"

extern Mutex_List<sub_container> sub_queue;

extern std::unordered_map<unsigned long, Device *> dev_table;

extern bool stop_soon;

class sig_dictionary {
private:
    int8_t ip_version;
    int32_t TTL;
    uint8_t badTTL;
    int32_t optLen;
    int32_t MSS;
    int8_t winType;
    int32_t winLen;
    int32_t winScale;
    int32_t optEOLPad;
    int32_t optNo;
    uint8_t optLayout[MAX_TCP_OPT];
    uint32_t quirks;
    int8_t payClass;
    std::string os_class;
    std::string os_name;

    bool ack;

public:
    sig_dictionary() {}

    sig_dictionary(const sig_dictionary& origin):
    ip_version(origin.ip_version),
    TTL(origin.TTL), badTTL(origin.badTTL), optLen(origin.optLen),
    MSS(origin.MSS), winType(origin.winType), winLen(origin.winLen),
    winScale(origin.winScale), optEOLPad(origin.optEOLPad),
    optNo(origin.optNo), quirks(origin.quirks), payClass(origin.payClass),
    os_class(origin.os_class), ack(origin.ack),
    os_name(origin.os_name){

        for (int i = 0; i < MAX_TCP_OPT; i++) {
            optLayout[i] = origin.optLayout[i];
        }
    }

    void setIPv(int8_t ip) {
        ip_version = ip;
    }

    int8_t getIPv() {
        return ip_version;
    }

    void setTTL(int32_t in_ttl) {
        TTL = in_ttl;
    }

    int32_t getTTL() {
        return TTL;
    }

    void setBadTTL(uint8_t in_bad_ttl) {
        badTTL = in_bad_ttl;
    }

    uint8_t getBadTTL() {
        return badTTL;
    }

    void setOptLen(int32_t in_opt_len) {
        optLen = in_opt_len;
    }

    int32_t getOptLen() {
        return optLen;
    }

    void setMSS(int32_t in_mss) {
        MSS = in_mss;
    }

    int32_t getMSS() {
        return MSS;
    }

    void setWinType(int8_t in_winType) {
        winType = in_winType;
    }

    int8_t getWinType() {
        return winType;
    }

    void setWinLen(int32_t &in_winLen) {
        winLen = in_winLen;
    }

    int32_t getWinLen()  {
        return winLen;
    }

    void setWinScale(int32_t in_winScale) {
        winScale = in_winScale;
    }

    int32_t getWinScale() {
        return winScale;
    }

    void setOptEOLPad(int32_t in_optEOLPad) {
        optEOLPad = in_optEOLPad;
    }

    int32_t getOptEOLPad() {
        return optEOLPad;
    }

    void setOptNo(int32_t in_optNo) {
        optNo = in_optNo;
    }

    int32_t getOptNo() {
        return optNo;
    }

    void setOptLayout(uint8_t* in_optLayout) {
        for (int i = 0; i < MAX_TCP_OPT; i++) {
            optLayout[i] = in_optLayout[i];
        }
    }

    uint8_t *getOptLayout() {
        return optLayout;
    }

    void setQuirks(uint32_t in_quirks) {
        quirks = in_quirks;
    }

    uint32_t getQuirks() {
        return quirks;
    }

    void setPayClass(int8_t in_payClass) {
        payClass = in_payClass;
    }

    int8_t getPayClass() {
        return payClass;
    }

    void setOSClass(std::string &in_os_class) {
        os_class = in_os_class;
    }

    std::string getOSClass() {
        return os_class;
    }

    void setOSName(std::string &in_os_name) {
        os_name = in_os_name;
    }

    std::string getOSName() {
        return os_name;
    }

    void setAck(bool val) {
        ack = val;
    }

    const bool& isAck() const {
        return ack;
    }
};

static void parse_classes(std::string &line);
static void parse_label(std::string &line);
static void parse_sig(std::string &line);
std::vector<std::string> parse_str(std::string &line, char separate);

// all informations
std::vector<sig_dictionary> informations;

// variables for parsing string
std::vector<std::string> str_parsed;

// variables for parsing classes
std::vector<std::string> fp_os_classes; //win = 0, unix = 1, other = 2

// variables for parsing label
int generics;
int sig_class; //win = 0, unix = 1, other = 2, non = -1
std::vector<std::string> fp_os_names;
int sig_name = 0;

// variables for parsing sig
int8_t ip_version;			// 1st ip version
int32_t iTTL;				// 2nd ittl
uint8_t bad_ttl;
int32_t olen;				// 3rd option length
int32_t mss;				// 4th mss
int8_t win_type;			// 5th window size
int32_t win;
int32_t wscale;				//     window scale
int32_t opt_eol_pad = 0;	// 6th option layout
int32_t optno;
uint8_t opt_layout[MAX_TCP_OPT];
uint32_t quirks = 0;	// 7th quirks
int8_t pay_class = 0;		// 8th payload class

static std::string detect_os(os_detect_data *os_data) {
    std::vector<sig_dictionary>::iterator sig_iter;
    std::string os = "Unknown";

    for (sig_iter = informations.begin(); sig_iter != informations.end(); sig_iter++) {
        if (sig_iter->isAck()) {
            if (os_data->tcp_type != (TCP_SYN | TCP_ACK)) continue;
        } else {
            if (os_data->tcp_type != TCP_SYN) continue;
        }

        // ip version check.
        if (sig_iter->getIPv() != -1)
            if (sig_iter->getIPv() != os_data->ip_v) continue;
        
        // ip ttl check.
        if (sig_iter->getTTL() < (int)os_data->ttl || sig_iter->getTTL()-32 > (int)os_data->ttl) continue;
        
        if (sig_iter->getMSS() != -1)
            if (sig_iter->getMSS() != os_data->mss) continue;
        
        // winsize
        if (sig_iter->getWinType() == WIN_TYPE_NORMAL) {
            if (sig_iter->getWinLen() != os_data->win) continue;
        } else if (sig_iter->getWinType() == WIN_TYPE_MSS) {
            if (sig_iter->getWinLen() * os_data->mss != os_data->win) continue;
        } else if (sig_iter->getWinType() == WIN_TYPE_MTU) {
            continue;
        } else if (sig_iter->getWinType() == WIN_TYPE_MOD) {
            continue;
        }
        
        // winscale
        if (sig_iter->getWinScale() != -1) {
            if (sig_iter->getWinScale() != os_data->wscale) continue;
        }
        
        // tcp opt
        bool opt_match = true;
        u_char *opt_layout = sig_iter->getOptLayout();
            
        for (int i = 0; i < os_data->o_cnt; i++) {
            if (opt_layout[i] != os_data->o_layout[i]) {
                opt_match = false;
                break;
            }
        }
        if (!opt_match) continue;
        
        
        //if (sig_iter->getQuirks() != (os_data->quirks & sig_iter->getQuirks())) continue;
        if (sig_iter->getQuirks() != (sig_iter->getQuirks() & os_data->quirks)) continue;
        
        os = sig_iter->getOSName();
        break;
    }
    
	return os;
}

void process_detection(pcap_pkthdr *header, u_char *packet, ndpi_iphdr *iph,
		ndpi_ipv6hdr *iph6, unsigned long packet_len, ndpi_protocol *protocol) {
	os_detect_data *os_data = NULL;
	tcphdr *tcp = NULL;
	u_char *opt_end = NULL;
	u_char *opt_data = NULL;

	std::string os = "Unknown";

	// packet processing for OS detection.
	if (iph) {
		if (iph->protocol == IPPROTO_TCP) {
			unsigned long hdr_len = (iph->ihl & 0x0F) * 4;
			unsigned short flags_off = ntohs(iph->frag_off);
			//unsigned short tot_len = ntohs(iph->tot_len);

			os_data = (os_detect_data *) malloc(sizeof(os_detect_data));
			// NEED Error handler!!!!!!!!!!!!!!

			os_data->ip_v = 0x04;
			os_data->ip_opt_len = hdr_len - 20;

			memcpy(&os_data->s_addr, &iph->saddr, 4);
			memcpy(&os_data->d_addr, &iph->daddr, 4);

			os_data->tos = iph->tos >> 2;
			os_data->ttl = iph->ttl;

			if (iph->tos & (0x01 | 0x02))
				os_data->quirks |= QUIRK_ECN;

			if (flags_off & 0x8000)
				os_data->quirks |= QUIRK_NZ_MBZ;

			if (flags_off & 0x4000) {
				os_data->quirks |= QUIRK_DF;
				if (iph->id)
					os_data->quirks |= QUIRK_NZ_ID;
			} else {
				if (!iph->id)
					os_data->quirks |= QUIRK_ZERO_ID;
			}
			os_data->tot_hdr = hdr_len;

			tcp = (struct tcphdr*) ((u_char *) iph + hdr_len);
			packet_len -= hdr_len;
		}
	} else {
		u_char ip_proto = iph6->ip6_ctlun.ip6_un1.ip6_un1_nxt;

		if (ip_proto == 0x3C /* IPv6 destination option */) {
			u_int8_t *options = (u_int8_t*) iph6
					+ sizeof(const struct ndpi_ipv6hdr);

			ip_proto = options[0];
		}

		if (ip_proto == IPPROTO_TCP) {
			struct ipv6_hdr *iphv6 = (struct ipv6_hdr *) iph6;
			unsigned long ver_tos_flow = ntohl(iphv6->ver_tos_flow);

			os_data = (os_detect_data *) malloc(sizeof(os_detect_data));
			// NEED Error handler!!!!!!!!!!!!!!

			os_data->ip_v = 0x06;
			os_data->ip_opt_len = 0;

			memcpy(&os_data->s_addr, &iphv6->src, 16);
			memcpy(&os_data->d_addr, &iphv6->dst, 16);
            
            os_data->s_addr = iph6->ip6_src.u6_addr.u6_addr32[2]
            + iph6->ip6_src.u6_addr.u6_addr32[3];
            
            os_data->d_addr = iph6->ip6_dst.u6_addr.u6_addr32[2]
            + iph6->ip6_dst.u6_addr.u6_addr32[3];

			os_data->tos = (ver_tos_flow >> 22) & 0x3F;

			os_data->ttl = iphv6->ttl;

			if (ver_tos_flow & 0xFFFFF)
				os_data->quirks |= QUIRK_FLOW;

			if ((ver_tos_flow >> 20) & (0x1 | 0x2))
				os_data->quirks |= QUIRK_ECN;

			os_data->tot_hdr = sizeof(struct ipv6_hdr);

			tcp = (struct tcphdr*) (iphv6 + 1);
			packet_len -= sizeof(struct ipv6_hdr);
		}
	}

	if (tcp) {

		os_data->tot_hdr += tcp->th_off * 4;

		os_data->s_port = ntohs(tcp->th_sport);
		os_data->d_port = ntohs(tcp->th_dport);

		os_data->tcp_type = tcp->th_flags
				& (TCP_SYN | TCP_ACK | TCP_FIN | TCP_RST);

		os_data->win = ntohs(tcp->th_win);
		os_data->seq = ntohs(tcp->th_seq);

		if ((tcp->th_flags & (0x40 | 0x80)) || (tcp->th_x2 & 0x1))
			os_data->quirks |= QUIRK_ECN;

		if (!os_data->seq)
			os_data->quirks |= QUIRK_ZERO_SEQ;

		if (tcp->th_flags & TCP_ACK) {
			if (tcp->th_ack)
				os_data->quirks |= QUIRK_ZERO_SEQ;
		} else {
			if (tcp->th_seq & !(tcp->th_flags & TCP_RST))
				os_data->quirks |= QUIRK_NZ_ACK;
		}

		if (tcp->th_flags & TCP_URG) {
			os_data->quirks |= QUIRK_URG;
		} else {
			if (tcp->th_urp)
				os_data->quirks |= QUIRK_NZ_URG;
		}

		if (tcp->th_flags & TCP_PUSH)
			os_data->quirks |= QUIRK_PUSH;

		if (tcp->th_off * 4 == packet_len) {
			os_data->payload = NULL;
			os_data->pay_len = 0;
		} else {
			os_data->payload = (u_char *) ((u_char*) tcp) + (tcp->th_off * 4);
			os_data->pay_len = packet_len - tcp->th_off * 4;
		}

		// TCP option processing
		os_data->o_cnt = 0;
		os_data->o_eol_pad = 0;
		os_data->mss = 0;
		os_data->wscale = 0;
		os_data->ts = 0;

		if (tcp->th_off > 5) {
			opt_end = (u_char *) tcp + tcp->th_off * 4;
			opt_data = (u_char *) (tcp + 1);

			while (opt_data < opt_end && os_data->o_cnt < 24) {
				os_data->o_layout[os_data->o_cnt++] = *opt_data;

				switch (*opt_data++) {
				case TCPOPT_EOL:
					os_data->o_eol_pad = opt_end - opt_data;

					while (opt_data < opt_end && !*opt_data++)
						;

					if (opt_data != opt_end) {
						os_data->quirks |= QUIRK_OPT_EOL_NZ;
						opt_data = opt_end;
					}

					break;

				case TCPOPT_NOP:
					break;

				case TCPOPT_MAXSEG:
					if (*opt_data != 4)
						os_data->quirks |= QUIRK_OPT_BAD;

					os_data->mss = ntohs(*(unsigned short *) (opt_data + 1));

					opt_data += 3;

					break;

				case TCPOPT_WSCALE:
					if (*opt_data != 3)
						os_data->quirks |= QUIRK_OPT_BAD;

					os_data->wscale = *(opt_data+1);

					if (os_data->wscale > 14)
						os_data->quirks |= QUIRK_OPT_EXWS;

					opt_data += 2;

					break;

				case TCPOPT_SACKOK:
					if (*opt_data != 2)
						os_data->quirks |= QUIRK_OPT_BAD;

					opt_data++;

					break;

				case TCPOPT_SACK:
					opt_data += *opt_data - 1;
					break;

				case TCPOPT_TSTAMP:
					if (*opt_data != 10)
						os_data->quirks |= QUIRK_OPT_BAD;

					os_data->ts = ntohl(*(unsigned long*) (opt_data + 1));

					if (!os_data->ts)
						os_data->quirks |= QUIRK_OPT_ZERO_TS;

					if (os_data->tcp_type == TCP_SYN
							&& (unsigned long *) (opt_data + 5))
						os_data->quirks |= QUIRK_OPT_NZ_TS2;

					opt_data += 9;

					break;

				default:
					opt_data += *opt_data - 1;
				}
			}

//			for (int i = 0; i < os_data->pay_len; i++)
	//			std::cout << (int)os_data->payload[i] << " " << std::endl;
		}
	}
    if (os_data && ((os_data->tcp_type == (TCP_SYN | TCP_ACK)) || os_data->tcp_type == TCP_SYN))
	os = detect_os(os_data);

	std::unordered_map<unsigned long, Device *>::iterator dev_iter;
    
    unsigned long s_addr = 0;
    
    if (iph) s_addr = iph->saddr;
    else if (iph6) s_addr = iph6->ip6_src.u6_addr.u6_addr32[2]
        + iph6->ip6_src.u6_addr.u6_addr32[3];

	dev_iter = dev_table.find(s_addr);

	if (dev_iter == dev_table.end()) {
		Device *new_dev = new Device(s_addr);
		new_dev->set_os("Unknown");

		dev_table.insert(std::pair<unsigned long, Device *>(s_addr, new_dev));

		dev_iter = dev_table.find(s_addr);
	}

    if (os_data && ((os_data->tcp_type == TCP_SYN) || (os_data->tcp_type == (TCP_SYN | TCP_ACK))))
        if (dev_iter->second->get_os() == "Unknown") {
            dev_iter->second->set_os(os);
            detect_velnerability(*dev_iter->second);
        }

    if(protocol)
        dev_iter->second->add_protocol(*protocol);



	free(os_data);
}

static void parse_classes(std::string &line) {
    std::string index;
    std::string temp;
    index = line.substr(10, line.size());
    
    for (int i = 0; i < index.size(); i++) {
        if (index[i] == ',') {
            temp = index.substr(0, i);
            fp_os_classes.push_back(temp);
            index = index.substr(i+1, index.size());
        }
    }
    fp_os_classes.push_back(index);
    
}

static void parse_label(std::string &line) {
    /*
     label = s:unix:Linux:2.6.x  «¸Ωƒ
     */
    
    std::string index;
    std::string temp;
    int i = 0, j = 0;
    
    // label = ¿ª ¡¶∞≈«œø© s:unix:Linux:2.6.x ∏∏ ≥≤±Ë
    index = line.substr(8, line.size());
    
    // g¿Œ¡ˆ s¿Œ¡ˆø° µ˚∂Û generics ∞™ º≥¡§
    if (index[0] == 'g') {
        generics = 1;
    }
    else if (index[0] == 's') {
        generics = 0;
    }
    
    // classes∞° !¿Ã∏È NMAP, ±◊ ø‹ classesø° ¿˙¿Âµ» ∞™. unix:Linux:2.6.x «¸Ωƒ
    if (index[2] == '!' && index[3] == ':') {
        sig_class = -1;
    }
    else {
        // fp_os_classesø° ¿˙¿Âµ» ∞™∞˙ ∫Ò±≥«œø© sig_class º≥¡§
        for (i = 2; index[i] != ':'; i++);
        
        temp = index.substr(2, i - 2);
        
        for (int k = 0; k < fp_os_classes.size(); k++) {
            if (!temp.compare(fp_os_classes[k])) {
                sig_class = k;
            }
        }
        
        // Linux:2.6.x «¸Ωƒ¿ª fp_os_namesø° ¿˙¿Â
        temp = index.substr(i+1, index.size() -2 );
        fp_os_names.push_back(temp);
        sig_name++;
    }
}

static void parse_sig(std::string &line) {
    std::vector<std::string> temp;
    temp = parse_str(line, ':');
    
    
    // sig¿« √ππ¯¬∞ ¡§∫∏: ip version
    switch (temp[0][0]) {
        case '4': ip_version = IP_VER4; break;
        case '6': ip_version = IP_VER6; break;
        case '*': ip_version = -1; break;
    }
    
    // sig¿« µŒπ¯¬∞ ¡§∫∏: TTL
    iTTL = atol(temp[1].c_str());
    if (iTTL < 1 || iTTL > 255)
        return;
    
    // sig¿« ººπ¯¬∞ ¡§∫∏: length of ip options
    olen = atol(temp[2].c_str());
    if (olen < 0 || olen > 255)
        return;
    
    // sig¿« ≥◊π¯¬∞ ¡§∫∏: MSS
    if (!isdigit(temp[3][0])) {
        mss = -1;
    }
    else {
        mss = atol(temp[3].c_str());
    }
    
    // sig¿« ¥Ÿº∏π¯¬∞ ¡§∫∏: window size
    if (temp[4][0] == '*' && temp[4][1] == ',') {
        win_type = WIN_TYPE_ANY;
        win = 0;
    }
    else if (temp[4][0] == '%') {
        int j;
        std::string str_win;
        
        for (j = 1; temp[4][j] != ','; j++);
        str_win = temp[4].substr(1, j);
        
        win = atol(str_win.c_str());
        win_type = WIN_TYPE_MOD;
    }
    else if (!temp[4].find("mss*") || !temp[4].find("mtu*")) {
        int j;
        std::string str_win;
        win_type = (temp[4][1] == 's') ? WIN_TYPE_MSS : WIN_TYPE_MTU;
        
        for (j = 4; temp[4][j] != ','; j++);
        str_win = temp[4].substr(4, j);
        win = atol(str_win.c_str());
    }
    else {
        int j;
        std::string str_win;
        win_type = WIN_TYPE_NORMAL;
        for (j = 0; temp[4][j] != ','; j++);
        str_win = temp[4].substr(0, j);
        win = atol(str_win.c_str());
    }
    
    // sig¿« ø©º∏π¯¬∞ ¡§∫∏: window scale
    std::string str_wscale;
    int j;
    
    for (j = 0; temp[4][j] != ','; j++);
    str_wscale = temp[4].substr(j + 1, temp[4].size());
    
    if (str_wscale[0] == '*') {
        wscale = -1;
    }
    else {
        wscale = atol(str_wscale.c_str());
    }
    // sig¿« ¿œ∞ˆπ¯¬∞ ¡§∫∏: option layout
    int count = 0;
    std::vector<std::string> opts;
    opts = parse_str(temp[5], ',');
    
    for (int m = 0; m < opts.size(); m++) {
        if (!opts[m].find("eol")) {
            opt_layout[count++] = TCPOPT_EOL;
            std::string eol_str = opts[m].substr(4, opts[m].size());
            
            opt_eol_pad = atol(eol_str.c_str());
            
            if (opt_eol_pad < 0 || opt_eol_pad > 255)
                return;
        }
        else if (!opts[m].compare("nop")) {
            opt_layout[count++] = TCPOPT_NOP;
        }
        else if (!opts[m].compare("mss")) {
            opt_layout[count++] = TCPOPT_MAXSEG;
        }
        else if (!opts[m].compare("ws")) {
            opt_layout[count++] = TCPOPT_WSCALE;
        }
        else if (!opts[m].compare("sok")) {
            opt_layout[count++] = TCPOPT_SACKOK;
        }
        else if (!opts[m].compare("sack")) {
            opt_layout[count++] = TCPOPT_SACK;
        }
        else if (!opts[m].compare("ts")) {
            opt_layout[count++] = TCPOPT_TSTAMP;
        }
        else if (!opts[m].find("?")) {
            std::string opt_str = opts[m].substr(1, opts[m].size());
            optno = atol(opt_str.c_str());
            
            if (optno < 0 || optno > 255) {
                return;
            }
            
            opt_layout[count++] = optno;
        }
        else {
            return;
        }
    }
    
    // sig¿« ø©¥¸π¯¬∞ ¡§∫∏: quirks
    std::vector<std::string> qrks;
    qrks = parse_str(temp[6], ',');
    
    for (int m = 0; m < qrks.size(); m++) {
        if (!qrks[m].compare("df")) {
            if (ip_version == IP_VER6)
                return;
            
            quirks |= QUIRK_DF;
        }
        else if (!qrks[m].compare("id+")) {
            if (ip_version == IP_VER6)
                return;
            
            quirks |= QUIRK_NZ_ID;
        }
        else if (!qrks[m].compare("id-")) {
            if (ip_version == IP_VER6)
                return;
            
            quirks |= QUIRK_ZERO_ID;
        }
        else if (!qrks[m].compare("ecn")) {
            quirks |= QUIRK_ECN;
        }
        else if (!qrks[m].compare("0+")) {
            if (ip_version == IP_VER6)
                return;
            
            quirks |= QUIRK_NZ_MBZ;
        }
        else if (!qrks[m].compare("flow")) {
            if (ip_version == IP_VER4)
                return;
            
            quirks |= QUIRK_FLOW;
        }
        else if (!qrks[m].compare("seq-")) {
            quirks |= QUIRK_ZERO_SEQ;
        }
        else if (!qrks[m].compare("ack+")) {
            quirks |= QUIRK_NZ_ACK;
        }
        else if (!qrks[m].compare("ack-")) {
            quirks |= QUIRK_ZERO_ACK;
        }
        else if (!qrks[m].compare("uptr+")) {
            quirks |= QUIRK_NZ_URG;
        }
        else if (!qrks[m].compare("urgf+")) {
            quirks |= QUIRK_URG;
        }
        else if (!qrks[m].compare("pushf+")) {
            quirks |= QUIRK_PUSH;
        }
        else if (!qrks[m].compare("ts1-")) {
            quirks |= QUIRK_OPT_ZERO_TS;
        }
        else if (!qrks[m].compare("ts2+")) {
            quirks |= QUIRK_OPT_NZ_TS2;
        }
        else if (!qrks[m].compare("opt+")) {
            quirks |= QUIRK_OPT_EOL_NZ;
        }
        else if (!qrks[m].compare("exws")) {
            quirks |= QUIRK_OPT_EXWS;
        }
        else if (!qrks[m].compare("bad")) {
            quirks |= QUIRK_OPT_BAD;
        }
        else {
            return;
        }
    }
    
    // sig¿« æ∆»©π¯¬∞ ¡§∫∏: payload class
    if (!temp[7].compare("*")) pay_class = -1;
    else if (!temp[7].compare("0")) pay_class = 0;
    else if (!temp[7].compare("+")) pay_class = 1;
    else return;
}

std::vector<std::string> parse_str(std::string &line, char separate) {
    std::vector<std::string> result;
    std::string temp;
    bool flag = false;
    int i = 0;
    
    std::size_t found2 = line.find('=');
    if (found2 != std::string::npos) {
    	line = line.substr(8, line.size());
    	}
    
    while (1) {
        std::size_t found = line.find(separate);
        if (found != std::string::npos) {
            for (i = 0; line[i] != separate; i++);
        }
        else {
            if (line.size() != 0) {
                result.push_back(line);
            }
            
            break;
        }
        
        temp = line.substr(0, i);
        result.push_back(temp);
        line = line.substr(i + 1, line.size());
    }
    
    return result;
}

void init_os_detection() {
    std::ifstream fin;
    std::string line;
    char cur;
    int i = 0;
    bool isResponsed = false;
    bool isRequested = false;
    
    informations.clear();
    
    fin.open("os_sig.db");
    
    while (std::getline(fin, line)) {
        cur = line[i];
        if (cur != ';') {
            if (!line.find("classes")) {
                parse_classes(line);
            }
            
            if (!line.compare("[tcp:response]")) {
                isResponsed = true;
                isRequested = false;
            }
            else if (!line.compare("[tcp:request]")) {
                isRequested = true;
                isResponsed = false;
            }
            
            if (!line.compare("[http:request]")) {
                isResponsed = false;
                isRequested = false;
            }
            
            
            
            if (isResponsed) {
                if (!line.find("label")) {
                    parse_label(line);
                }
                
                if (!line.find("sig")) {
                    parse_sig(line);
                    if (sig_class >= 0) {
                        sig_dictionary information;
                        information.setIPv(ip_version);
                        information.setTTL(iTTL);
                        information.setBadTTL(bad_ttl);
                        information.setMSS(mss);
                        information.setWinType(win_type);
                        information.setWinLen(win);
                        information.setWinScale(wscale);
                        information.setOptEOLPad(opt_eol_pad);
                        information.setOptLen(olen);
                        information.setOptNo(optno);
                        information.setOptLayout(opt_layout);
                        information.setQuirks(quirks);
                        information.setPayClass(pay_class);
                        information.setOSClass(fp_os_classes[sig_class]);
                        information.setOSName(fp_os_names[sig_name - 1]);
                        information.setAck(true);
                        informations.push_back(information);
                    }
                    
                }
            }
            else if (isRequested) {
                if (!line.find("label")) {
                    parse_label(line);
                }
                
                if (!line.find("sig")) {
                    parse_sig(line);
                    if (sig_class >= 0) {
                        sig_dictionary information;
                        information.setIPv(ip_version);
                        information.setTTL(iTTL);
                        information.setBadTTL(bad_ttl);
                        information.setMSS(mss);
                        information.setWinType(win_type);
                        information.setWinLen(win);
                        information.setWinScale(wscale);
                        information.setOptEOLPad(opt_eol_pad);
                        information.setOptLen(olen);
                        information.setOptNo(optno);
                        information.setOptLayout(opt_layout);
                        information.setQuirks(quirks);
                        information.setPayClass(pay_class);
                        information.setOSClass(fp_os_classes[sig_class]);
                        information.setOSName(fp_os_names[sig_name - 1]);
                        information.setAck(false);
                        informations.push_back(information);
                    }
                }
            }
        }
    }
    informations.size();
    fin.close();
}

void run_os_detection() {
    sub_container container;
    while (!stop_soon) {
        if (!sub_queue.empty()) {
			sub_queue.lock();

			container = sub_queue.front();
			sub_queue.pop_front();

			sub_queue.unlock();

			process_detection(container.header, container.packet, container.iph,
					container.iph6, container.packet_len, container.protocol);

			free(container.header);
			free(container.packet);
            free(container.protocol);
		}
	}
}

void stop_os_detection() {
	stop_soon = true;
}
