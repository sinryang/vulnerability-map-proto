var w = 1000,
    h = 1000;

var duration = 1000;

var firstRound = true;

var transition = false;

var GraphView = Backbone.View.extend({
        el: "#graph",
        info: "#info_container",

        initialize: function () {
            _.bindAll(this, "render");
            _.bindAll(this, "tick");
            _.bindAll(this, "mouseOver");
            _.bindAll(this, "mouseOut");
            _.bindAll(this, "mouseDown");

            this.model.bind("changes", this.render);

            this.tip = d3.tip()
                .attr('class', 'd3-tip')
                .offset([-10, 0])
                .html(function (d) {
                    return "<span style='color:red'>" + d.name + "</span>";
                });

            drag = false;

            this.svg = d3.select(this.$el.selector)
                .append("svg")
                .attr("class", "graphsvg")
                .attr("width", w)
                .attr("height", h)
                .style("background-color", "#EEEEEE")
                .append("g")
                .attr("prepare", "translate(15,10)")
                .call(this.tip);

            this.nodes = [];
            this.links = [];

            this.force = d3.layout.force()
                .nodes(this.nodes)
                .links(this.links)
                .gravity(0.05)
                .charge([-500])
                .theta(0.1)
                .linkDistance(120)
                .size([w, h])
                .on("tick", this.tick);

            this.nodeDrag = this.force.drag()
                .on("dragstart", this.dragStart)
                .on("dragend", this.dragEnd);

            this.node = this.svg.selectAll(".node");

            this.link = this.svg.selectAll(".link");

            this.template = $("#info_template").html();

            this.centerNodeData;

            theModel = this.model; //hack
        },

        setInfo: function (hoverNodeName,hoverNodeNumberEdges, hoverLayer) {
            console.log("setInfo");

            $(this.info).html(_.template(this.template, {
                center_node_name: this.centerNodeData.get("name"),
                //center_node_number_edges: this.centerNodeData.getNeighborhood().length,
                hover_node_name: hoverNodeName,
                //hover_node_number_edges: hoverNodeNumberEdges,
                layer_of_nodes: hoverLayer
            }));
        },

        render: function (centerNode, data) {
            console.log("render", centerNode.get("name"));

    this.nodelabels = this.svg.selectAll(".nodelabel").data(this.nodes).remove();

            this.centerNodeData = centerNode;

            this.setInfo();

            var d3Data = this.prepare(data);

            var allNodesMap = d3.map();

            for (var i = this.nodes.length - 1; i >= 0; i--) {
                var node = this.nodes[i];
                
                if (d3Data.nodeIdMap.has(node.id)) {
                    //node already in the graph
                    node.centerNode = d3Data.nodeIdMap.get(node.id).centerNode;

                    d3Data.nodeIdMap.remove(node.id);
                    allNodesMap.set(node.id, node);
                }
                else {
                    //remove unnecessary node from the graph
                    this.nodes.splice(i, 1);
                }
            }

            var nn = d3Data.nodeIdMap.values();

            for (var i = 0; i < nn.length; i++) {
                //add new node to the graph
                this.nodes.push(nn[i]);
                allNodesMap.set(nn[i].id, nn[i]);
            }

            for (var i = this.links.length - 1; i >= 0; i--) {
                var edge = this.links[i];
                
                if (d3Data.edgeIdMap.has(edge.id)) {
                    //edge already in the graph
                    d3Data.edgeIdMap.remove(edge.id);
                }
                else {
                    //remove unnecessary edge from the graph
                    this.links.splice(i, 1);
                }
            }

            var ne = d3Data.edgeIdMap.values();

            for (var i = 0; i < ne.length; i++) {
                //add new edge to the graph
                var e = {source: allNodesMap.get(ne[i].source), target: allNodesMap.get(ne[i].target) };
                this.links.push(e);
            }

            this.start(centerNode);
        },

        tick: function () {
            //    console.log("tick");

/*
	    if (d.layer < 2) {
	    	this.node
		    .attr("cx", function (d) { return d.x; })
		    .attr("cy", function (d) { return d.y; })
	    }
	    else {
		this.node
		    .attr("x", function (d) { return d.x; })
		    .attr("y", function (d) { return d.y; })
	    }
*/

            this.node
                .attr("cx", function (d) {
                    return d.x;
                })
                .attr("cy", function (d) {
                    return d.y;
                });

/*
	    this.node.each(function(d) {
                if (d.layer < 3) {
                    this.setAttribute('cx', d.x);
                    this.setAttribute('cy', d.y);
                }
		else {
                    this.setAttribute('x', d.x - 18);
                    this.setAttribute('y', d.y - 18);
		}
            });
*/

            this.link.attr("x1", function (d) {
                return d.source.x;
            })
                .attr("y1", function (d) {
                    return d.source.y;
                })
                .attr("x2", function (d) {
                    return d.target.x;
                })
                .attr("y2", function (d) {
                    return d.target.y;
                })
            
            this.nodelabels.attr("x", function(d) { return d.x - d.name.length*4; }) 
                  .attr("y", function(d) { 
				if (d.layer == 1) {
					return d.y + 46;
				}
				return d.y + 34; });
        },

        start: function (centerNode) {
            console.log("start");

            this.link = this.link.data(this.force.links(), function (d) {
                return d.source.id + "-" + d.target.id;
            });

            this.link.enter().insert("line", ".node").attr("class", "link")
                .style("opacity", 0)
                .transition().duration(1000)
                .style("opacity", 1);

            this.link.exit()
                .remove();

            this.node = this.node.data(this.force.nodes(), function (d) {
                return d.id;
            });

            if (this.node.enter().empty()==false ||this.node.exit().empty() == false) {
                transition = true;
            }

/*
	    if (centerNode.get("layer") < 3) {
		console.log("layer1: " + centerNode.get("layer"));
            	this.node.enter()
                    .append("circle")
                    .style("opacity", 0)
                    .attr("class", "node")
                    .style("fill", function (d) {
                        return d.color;
                    })
                    .attr("r", 18)
                    .on('mouseover', this.mouseOver)
                    .on('mousedown', this.mouseDown)
                    .on('mouseout', this.mouseOut)
                    .on("dragstart", this.dragStart)
                    .on("click", this.click)
                    .call(this.nodeDrag)
                    .transition().duration(1000)
                    .style("opacity", 1)
                    .each("end",function(){transition=false;});
	    }
*/
/*
	    console.log("centerNode.layer: " + centerNode.get("layer"));
            this.node.enter()
                .append("rect")
                .style("opacity", 0)
                .attr("class", "node")
                .style("fill", function (d) {
                    return d.color;
                })
		.attr("width", 40)
		.attr("height", 20)
                .on('mouseover', this.mouseOver)
                .on('mousedown', this.mouseDown)
                .on('mouseout', this.mouseOut)
                .on("dragstart", this.dragStart)
                .on("click", this.click)
                .call(this.nodeDrag)
                .transition().duration(1000)
                .style("opacity", 1)
                .each("end",function(){transition=false;});
*/
	    console.log("centerNode.layer: " + centerNode.get("layer"));
            this.node.enter()
                .append("circle")
                .style("opacity", 0)
                .attr("class", "node")
                .style("fill", function (d) {
                    return d.color;
                })
		.attr("r", 18)
                .on('mouseover', this.mouseOver)
                .on('mousedown', this.mouseDown)
                .on('mouseout', this.mouseOut)
                .on("dragstart", this.dragStart)
                .on("click", this.click)
                .call(this.nodeDrag)
                .transition().duration(1000)
                .style("opacity", 1)
                .each("end",function(){transition=false;});


  /*this.node.append("text")
      .attr("dx", 12)
      .attr("dy", ".35em")
      .text(function(d) { return d.name });*/

            this.node.each(function(d) {
                if (d.layer == 1) {
                    this.setAttribute('r',30);
                }
                else {
                    if (d.centerNode==false) {
                      this.setAttribute('r',18);
                    }
                    else if (firstRound) {
                        this.setAttribute('r',30);
                        firstRound  =false;
                    }
                }
            });
    
    this.nodelabels = this.svg.selectAll(".nodelabel") 
       .data(this.nodes)
       .enter()
       .append("text")
       .attr({"x":function(d){return d.x;},
              "y":function(d){return d.y;},
              "class":"nodelabel"})
       .text(function(d){return d.name;});

            this.node.exit().transition().duration(1000).style("opacity", 0)
                .each("end",function(){transition=false;})
                .remove();

            this.force.start()
        },

        dragStart: function () {
            if(transition) return;

            drag = true;
            d3.select(this)
                .style("fill", "orange");
        },

        dragEnd: function (d) {
            console.log("dragEnd");
            drag = false;
            d3.select(this)
                .style("fill", d.color);
        },

        mouseOver: function (d) {
           //console.log("mouseOver",d);

            if(transition) return;
            if (drag == false) {
                d3.select(d3.event.toElement)
                    .transition()
                    .duration(250)
                    .style("fill", "#D9E5FF");
                this.tip.show(d);
                d.fixed = true;
                this.setInfo(d.name, d.numberOfEdges, d.layer);
            }
        },

        mouseDown: function(d) {
            this.tip.hide();
        },

        mouseOut: function (d) {
            console.log("mouseOut",d3.event.fromElement);
            if(transition) return;
            if(drag == false) {

                d3.select(d3.event.fromElement)
                  .transition()
                  .duration(250)
                  .style("fill", d.color);
                
                this.tip.hide();
                
                d.fixed = false;
                
                this.setInfo();
            }
        },

        click: function (d) {
            var infos = [];
            var info;
            var entireInfo = "";
            var vulnerInfo = "[ Vulnerability List ]<hr/>";
            
            console.log("click", d3.event);
            if(transition) return;

            if (d3.event.defaultPrevented) return;
            
            if (d.layer == 1) {
            d3.select(this)
                .transition().duration(250)
                .style("fill", d.color)
                .attr("r",30);
            }
            else if (d.layer == 2) {
            d3.select(this)
                .transition().duration(250)
                .style("fill", d.color)
                .attr("r",24);
            }
            
            d.nodelabel;
            
            if (d.layer == 1) {
                theModel.fetch(d.id, 1)
            }
            else if (d.layer == 2) {
                theModel.fetch(d.id, 2)
            }
			
            //nodeCollection = theModel.getNodeCollection();
            
			// 노드 클릭시 취약성 정보 출력
			if (d.layer == 1) {
				infos = theModel.getInformation(d, 3);
			}
			else if (d.layer == 2) {
				infos = theModel.getInformation(d, 2);
			}
			else if (d.layer == 3) {
				infos = theModel.getInformation(d, 1);
			}
			else {
                                info = "선택한 노드의 취약성 정보를 보여줍니다.";
			}
            
            if (d.layer != 4) {
                for (var i = 0; i < infos.length; i++) {
                    entireInfo += (infos[i]);
                }
            }
            else {
                entireInfo = info;
            }
            
            vulnerInfo += entireInfo;
            $(".vulner_container").html(vulnerInfo);
        },

        prepare: function (modelData) {
            //   console.log("prepare", modelData);

            var nodeIdMap = d3.map();
            var edgeIdMap = d3.map();
            var id2index = d3.map();

            for (var i = 0; i < modelData.length; i++) {
                var id = modelData[i].id;
                var name = modelData[i].get("name");
                var layer = modelData[i].get("layer");
                var color = modelData[i].get("color");
                var vulnerable = modelData[i].get("vulner");
                var score = modelData[i].get("score");
                var noe = modelData[i].getNeighborhood().length;

                var node = {id: id, layer: layer, name: name, color: color,numberOfEdges: noe,
                centerNode: i==0, vulnerable: vulnerable, score: score
            };

            nodeIdMap.set(id, node);
        }

        for (var i = 0; i < modelData.length; i++) {

            var nodeA = modelData[i];

            var neighborhood = nodeA.getNeighborhood();

            for (var j = 0; j < neighborhood.length; j++) {
                var nodeB = neighborhood.at(j);

                if (nodeIdMap.has(nodeB.id) && nodeA.cid.localeCompare(nodeB.cid) > 0) {

                    var sourceId = nodeA.id;
                    var targetId = nodeB.id;

                    var id = sourceId + "-" + targetId;
                    var edge = {source: sourceId, target: targetId, id: id  };

                    edgeIdMap.set(id, edge);
                }
            }
        }

        return {nodeIdMap: nodeIdMap, edgeIdMap: edgeIdMap};
    }
});
